/*********************************************************************
 * Usage of this software requires acceptance of the SMASH-CMU License,
 * which can be found at the following URL:
 *
 * https://code.google.com/p/smash-cmu/wiki/License
 *********************************************************************/

#pragma once

#ifdef V_REP

#include "platforms/platform.h"
#include "movement/platform_movement.h"
#include "sensors/platform_sensors.h"

#include "madara/knowledge_engine/Knowledge_Base.h"

#include "v-rep_madara_variables.h"

#include <string>
#include <cmath>
#include <map>

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Macros, constants and enums.
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// For Windows compatibility.
#ifndef M_PI
	#define M_PI 3.14159265358979323846
#endif

// Conversion from degrees to radians.
#define DEG_TO_RAD(x) (x)*M_PI/180.0

// Define the ids for the internal expressions.
enum VRepMadaraExpressionId 
{
    // Updated the command id.
    VE_UPDATE_COMMAND_ID, 
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Variables.
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// NOTE: We are using a hack here, assuming that an external Main module will set this id.
extern int g_id;

// Map of Madara expressions.
static std::map<VRepMadaraExpressionId, Madara::Knowledge_Engine::Compiled_Expression> m_expressions;

// The knowledge base.
static Madara::Knowledge_Engine::Knowledge_Base*m_sim_knowledge;

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Internal functions.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void compileExpressions(Madara::Knowledge_Engine::Knowledge_Base* knowledge);

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Overrides: init_platform().
////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool init_platform()
{
    // Used for updating various transport settings
    Madara::Transport::Settings transportSettings;

    // Define the transport.
    transportSettings.hosts_.resize (1);
    transportSettings.hosts_[0] = DEFAULT_MULTICAST_ADDRESS;
    transportSettings.type = Madara::Transport::MULTICAST;
    transportSettings.domains = VREP_DOMAIN;

    // Sets the id. NOTE: we are assuming that g_id will be setup externally by the code.
    transportSettings.id = g_id;
    
    // Create the knowledge base.
    std::string host = "";
    m_sim_knowledge = new Madara::Knowledge_Engine::Knowledge_Base(host, transportSettings);

    // Define Madara functions.
    compileExpressions(m_sim_knowledge);

    // Set the ID inside Madara.
    m_sim_knowledge->set (".id", (Madara::Knowledge_Record::Integer) transportSettings.id);

	// Indicate that we have not sent or received replied to commands yet. The first id sent will be 1.
    // NOTE: this is currently not being used for anything other than debugging. It could be used to fix a bug where
    // commands some times do not get sent for some reason to the Madara base in VRep, by checking if no "acks" have
    // beeen recieved from VRep.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MS_SIM_CMD_SENT_ID, (Madara::Knowledge_Record::Integer) 0,
                Madara::Knowledge_Engine::Eval_Settings(true, true));
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MS_SIM_CMD_RCVD_ID, (Madara::Knowledge_Record::Integer) 0,
                Madara::Knowledge_Engine::Eval_Settings(true, true));
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Overrides: cleanup_platform().
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool cleanup_platform()
{
    m_sim_knowledge->print_knowledge();

	// Cleanup Madara.
	m_sim_knowledge->close_transport();
    m_sim_knowledge->clear();
    delete m_sim_knowledge;

    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Registers functions with Madara.
// ASSUMPTION: Drone IDs are continuous, starting from 0.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void compileExpressions(Madara::Knowledge_Engine::Knowledge_Base* knowledge)
{
    m_expressions[VE_UPDATE_COMMAND_ID] = knowledge->compile(
        "("
			// Send the command id after increasing it. We first increase it so the first id sent is 1.
			"++" MS_SIM_DEVICES_PREFIX "{.id}" MS_SIM_CMD_SENT_ID";"
        ")"
    );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Movement Functions.
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool init_control_functions()
{
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void takeoff()
{
    // Send the command.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_REQUESTED, MO_TAKEOFF_CMD);

    // Update the command id.
    m_sim_knowledge->evaluate(m_expressions[VE_UPDATE_COMMAND_ID]);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void land()
{
    // Send the command.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_REQUESTED, MO_LAND_CMD);

    // Update the command id.
    m_sim_knowledge->evaluate(m_expressions[VE_UPDATE_COMMAND_ID]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_up()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_down()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_left()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_right()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_forward()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_backward()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_to_location(double lat, double lon, double alt)
{
    // Set the arguments for this command. Note that we are intentionally ignoring altitude, as the 
    // simulation is doing that as of now.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_CMD_ARG("0"), lat);
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_CMD_ARG("1"), lon);

    // Send the command.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_REQUESTED, MO_MOVE_TO_GPS_CMD);

    // Update the command id.
    m_sim_knowledge->evaluate(m_expressions[VE_UPDATE_COMMAND_ID]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_to_altitude(double alt)
{
    // Set the arguments for this command. Note that we are intentionally ignoring altitude, as the 
    // simulation is doing that as of now.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_CMD_ARG("0"), alt);

    // Send the command.
    m_sim_knowledge->set(MS_SIM_DEVICES_PREFIX "{.id}" MV_MOVEMENT_REQUESTED, MO_MOVE_TO_ALTITUDE_CMD);

    // Update the command id.
    m_sim_knowledge->evaluate(m_expressions[VE_UPDATE_COMMAND_ID]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void stop_movement()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sensor Functions.
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool init_sensor_functions()
{
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void read_thermal(double buffer[8][8])
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets the GPS coordinates from the simulator and gives them back to the 
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void read_gps(struct madara_gps * ret)
{
    // Get the latitude and longitude that the simulator set for this drone, in variables with the sim prefix.
    double latitude = m_sim_knowledge->get(m_sim_knowledge->expand_statement(MS_SIM_DEVICES_PREFIX "{.id}" MV_LATITUDE)).to_double();
    double longitude = m_sim_knowledge->get(m_sim_knowledge->expand_statement(MS_SIM_DEVICES_PREFIX "{.id}" MV_LONGITUDE)).to_double();
	double altitude = m_sim_knowledge->get(m_sim_knowledge->expand_statement(MS_SIM_DEVICES_PREFIX "{.id}" MV_ALTITUDE)).to_double();

    //std::cout << "Lat " << latitude << ", Long " << longitude << " from: " << std::string(MS_SIM_PREFIX MV_DEVICE_LAT("{"MV_MY_ID"}")) << std::endl;
    //m_sim_knowledge->print_knowledge();

    // Set the values in the return structure.
	ret->latitude = latitude;
	ret->longitude = longitude;
	ret->altitude = altitude;
	ret->num_sats = 10;             // Just because it should be really exact with the simulator.
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets the altitude from the ultrasound sensor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
double read_ultrasound()
{
    return m_sim_knowledge->get(m_sim_knowledge->expand_statement(MS_SIM_DEVICES_PREFIX "{.id}" MV_ALTITUDE)).to_double();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Calculate the distance between two coordinate pairs.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
static double gps_coordinates_distance (double lat1, double long1, double lat2, double long2)
{
    const double EARTH_RADIUS = 6371000;

    // Get the difference between our two points then convert the difference into radians
    double lat_diff = DEG_TO_RAD(lat2 - lat1);
    double long_diff = DEG_TO_RAD(long2 - long1);

    lat1 =  DEG_TO_RAD(lat1);
    lat2 =  DEG_TO_RAD(lat2);

    double a =  pow(sin(lat_diff/2),2)+
                cos(lat1) * cos(lat2) *
                pow ( sin(long_diff/2), 2 );

    double c = 2 * atan2( sqrt(a), sqrt( 1 - a));
    return EARTH_RADIUS * c;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Calculate the distance between a given GPS location and our current GPS location.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
double get_distance_to_gps(double lat, double lon)
{
    double curLat = m_sim_knowledge->get(MS_SIM_DEVICES_PREFIX "{.id}" MV_LATITUDE).to_double();
    double curLong = m_sim_knowledge->get(MS_SIM_DEVICES_PREFIX "{.id}" MV_LONGITUDE).to_double();

    return gps_coordinates_distance(curLat, curLong, lat, lon);
}

#endif
